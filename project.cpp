	//============================================================================	// Name        : kernelOs.cpp	// Author      : khizar	// Version     :	// Copyright   : Your copyright notice	// Description : Hello World in C++, Ansi-style	//============================================================================		#include <iostream>	#include <fstream>	#include <stdlib.h>	#include <signal.h>	#include <fcntl.h>	#include <cstring>	#include <unistd.h>	#include <string>	#include <sstream>	#include <queue>	#include <sys/wait.h>	#include <sys/stat.h>		using namespace std;		struct pcb {		pid_t pid;		string ir;		int pc;		int state;  // 0 blocked,1 ready,2 running		float starttime;		float elapsedtime;		string *instArr;		int value;  //value which will be manipulated by the instructions		int inCount;		bool dead;		float turnaroundTime;		pcb()//default constructor		{			pid=0; //			ir="";			pc=0;			state=-1; //yet to be be decided			starttime=0; //here time variable of controller process will be used			elapsedtime=0;			value=0;			inCount=0;			dead=false;			turnaroundTime=0;			}			pcb(pid_t pd,float time)		{			pid=pd; //			ir="";			pc=0;			state=1; //ready state of new program			starttime=time; //here time variable of controller process will be used			elapsedtime=time;				value=0;			inCount=0;			dead=false;			turnaroundTime=0;		}		~pcb()		{			delete []instArr;		}				pcb& operator=(const pcb & process)		{			if (this != &process)			{				this->pid=process.pid;				this->ir=process.ir;				this->pc=process.pc;				this->state=process.state;				this->starttime=process.starttime;				this->elapsedtime=process.elapsedtime;				this->instArr=process.instArr;				this->value=process.value;				this->inCount=process.inCount;				this->dead=process.dead;				this->turnaroundTime=process.turnaroundTime;			}			return *this;			}		};			pcb cpu;	queue <pid_t> readyQueue;	int sizeOfPcbTable=100;	int countOfPcbTable=0;	pcb *pcbTable=new pcb[sizeOfPcbTable];	queue <string>commandQueue;	int timme=0;			queue <pid_t> blockedQueue;	queue <pid_t> runningQueue; //only store pid of process to minimize the memory usage	int incCount=0;	//int time=0;// time variable for controller		pid_t incPid;	int pidSerialNo=1;	void premptHandler(int val)	{				if(!runningQueue.empty())		{			for(int i=0;i<countOfPcbTable;i++)			{				if(pcbTable[i].pid==cpu.pid)				{					cpu.state=1;//ready state					pcbTable[i]=cpu;					break;				}			}			readyQueue.push(cpu.pid);			runningQueue.pop();					}		if(!readyQueue.empty())		{			pid_t x=readyQueue.front();			readyQueue.pop();					for(int i=0;i<countOfPcbTable;i++)			{				if(pcbTable[i].pid==x && pcbTable[i].dead==false && pcbTable[i].state==1 )				{					cpu=pcbTable[i];					cpu.state=2;					runningQueue.push(x);					//cout<<"prempt"<<endl;					break;				}			}		}else		{			cout<<"readyQueue is empty can't prempt"<<endl;		}			}				pid_t contPid;	char buff[30];	int count=0;//for pcb table	int fd[2];	int k=pipe(fd);		bool exitt=false;		void inputHandler(int val)	{			if(exitt==true)		return;		cout<<"ENTER NEXT command in the inCahrge process"<<endl;		for(int i=0;i<25;i++)		{			buff[i]='\0';		}		cin.getline(buff,sizeof(buff));			close(fd[0]);		write(fd[1],buff,sizeof(buff));				kill(contPid,SIGINT);		}						char buff2[30];		void readHandler(int val)	{			cout<<"read handler "<<endl;		for(int i=0;i<30;i++)		{			buff2[i]='\0';		}			close(fd[1]);			read(fd[0],buff2,sizeof(buff));		string cmd(buff2);			cout<<"received queue in controller in handler"<<cmd<<endl;		commandQueue.push(cmd);			string exeCommand;		exeCommand= commandQueue.front();			commandQueue.pop();		string fArg="";		int tokenIndex=0;			for(int i=0;exeCommand[tokenIndex]!=' ' && exeCommand[tokenIndex]!='\0';tokenIndex++,i++)		{						fArg+=exeCommand[tokenIndex];		}		tokenIndex++;		//cout<<"comman recieved is "<<exeCommand<<endl;				string secArg;		//for create process		if(fArg=="CRT")		{				pcb temp(pidSerialNo,timme);			pidSerialNo++;				//pcbTable			for(int i=0;exeCommand[tokenIndex]!=' ' && exeCommand[tokenIndex]!='\0';tokenIndex++,i++)			{				secArg+=exeCommand[tokenIndex];			}					///form a new index of pCB array and add the				temp.instArr=new string[50];//make dynamic					string line;				//			ifstream file((char*)secArg.c_str());			//cout<<"secargument changing to characters"<<secArg.c_str()<<endl;			if (file.is_open())			{				int k=0;				while( getline( file , line ) )				{                       //chance of memory leak make a funtion to copy value only					temp.instArr[k++]=line;					temp.inCount++;					}				file.close();			}			else				cout<<"CRT file not opened \n";					temp.state=1;			pcbTable[countOfPcbTable++]=temp;				readyQueue.push(temp.pid);			//cout<<"pushed \n";			for(int i=0;i<temp.inCount;i++)			{				cout<<temp.instArr[i]<<endl;			}		}//CRT finished executing			if(fArg=="UNB")		{			if(!blockedQueue.empty())			{				pid_t p=blockedQueue.front();				for(int i=0;i<countOfPcbTable;i++)				{					if(pcbTable[i].pid==p)					{						pcbTable[i].state=1;						break;					}				}				readyQueue.push(p);					blockedQueue.pop();			}			}//unblock process ends				if(fArg=="PRT")		{			cout<<"CURRENT TIME: "<<timme<<endl<<endl;			cout<<"RUNNING PROCESS: \n";			if(!runningQueue.empty())			{						cout<<"pid "<<cpu.pid<<" ,ppid "<<contPid<<" ,value "<<cpu.value<<" ,startTime "<<cpu.starttime<<" ,timeUsedSoFar "<<cpu.elapsedtime-cpu.starttime<<endl;						}			cout<<"BLOCKED PROCESSES:\nQueue of blocked processes:\n";			queue <pid_t> temp;			 pid_t haspid=0;			 while(!blockedQueue.empty())			 {				 haspid=blockedQueue.front();				 blockedQueue.pop();				 for(int i=0;i<countOfPcbTable;i++)				 {					 if(haspid==pcbTable[i].pid)					 {						 cout<<"pid "<<pcbTable[i].pid<<" ,ppid "<<contPid<<" ,value "<<pcbTable[i].value<<" ,startTime "<<pcbTable[i].starttime<<" ,timeUsedSoFar "<<pcbTable[i].elapsedtime-pcbTable[i].starttime<<endl;						break;					 }				 }				 temp.push(haspid);				 			 }			 haspid=0;			  while(!temp.empty())			 {				  haspid=temp.front();				 temp.pop();				 blockedQueue.push(haspid);			 }			 cout<<"PROCESSES READY TO EXECUTE:\nQueue of ready processes:\n";			  while(!readyQueue.empty())			 {				 haspid=readyQueue.front();				 readyQueue.pop();				 for(int i=0;i<countOfPcbTable;i++)				 {					 if(haspid==pcbTable[i].pid)					 {						 cout<<"pid "<<pcbTable[i].pid<<" ,ppid "<<contPid<<" ,value "<<pcbTable[i].value<<" ,startTime "<<pcbTable[i].starttime<<" ,timeUsedSoFar "<<pcbTable[i].elapsedtime-pcbTable[i].starttime<<endl;						break;					 }				 }				 temp.push(haspid);				 			 }			 haspid=0;			  while(!temp.empty())			 {				  haspid=temp.front();				 temp.pop();				 readyQueue.push(haspid);			 }			 			 								}		if(fArg=="END")		{						int countexit=0;			float sum=0;			 for(int i=0;i<countOfPcbTable;i++)				 {					 if(pcbTable[i].dead=true)					 {						 sum+=pcbTable[i].turnaroundTime;						 countexit++;					 }				 }			sum=sum/countexit;						cout<<"Average turnAround-time is : "<<sum<<endl;				cout<<"CURRENT TIME: "<<timme<<endl<<endl;			cout<<"RUNNING PROCESS: \n";			if(!runningQueue.empty())			{						cout<<"pid "<<cpu.pid<<" ,ppid "<<contPid<<" ,value "<<cpu.value<<" ,startTime "<<cpu.starttime<<" ,timeUsedSoFar "<<cpu.elapsedtime-cpu.starttime<<endl;						}			cout<<"BLOCKED PROCESSES:\nQueue of blocked processes:\n";			queue <pid_t> temp;			 pid_t haspid=0;			 while(!blockedQueue.empty())			 {				 haspid=blockedQueue.front();				 blockedQueue.pop();				 for(int i=0;i<countOfPcbTable;i++)				 {					 if(haspid==pcbTable[i].pid)					 {						 cout<<"pid "<<pcbTable[i].pid<<" ,ppid "<<contPid<<" ,value "<<pcbTable[i].value<<" ,startTime "<<pcbTable[i].starttime<<" ,timeUsedSoFar "<<pcbTable[i].elapsedtime-pcbTable[i].starttime<<endl;						break;					 }				 }				 temp.push(haspid);				 			 }			 haspid=0;			  while(!temp.empty())			 {				  haspid=temp.front();				 temp.pop();				 blockedQueue.push(haspid);			 }			 cout<<"PROCESSES READY TO EXECUTE:\nQueue of ready processes:\n";			  while(!readyQueue.empty())			 {				 haspid=readyQueue.front();				 readyQueue.pop();				 for(int i=0;i<countOfPcbTable;i++)				 {					 if(haspid==pcbTable[i].pid)					 {						 cout<<"pid "<<pcbTable[i].pid<<" ,ppid "<<contPid<<" ,value "<<pcbTable[i].value<<" ,startTime "<<pcbTable[i].starttime<<" ,timeUsedSoFar "<<pcbTable[i].elapsedtime-pcbTable[i].starttime<<endl;						break;					 }				 }				 temp.push(haspid);				 			 }			 haspid=0;			  while(!temp.empty())			 {				  haspid=temp.front();				 temp.pop();				 readyQueue.push(haspid);			 }			 			 												exitt=true;			cout<<"child "<<contPid<<endl;			cout<<"parent "<<incPid<<endl;			kill(incPid,SIGKILL);			kill(contPid,SIGKILL);					}							if(fArg=="INC")		{	cout<<"INC called "<<endl;	incCount++;	cout<<"inc value is "<<incCount<<endl;	if(!(cpu.pc >=cpu.inCount))	{		//cout<<cpu.pc<<endl;							string cmd=cpu.instArr[cpu.pc];			cpu.pc++;			cpu.elapsedtime++;			timme++;			string fPart;			string secPart;				int tokenIndex=0;				for(int i=0;cmd[tokenIndex]!=' ' && cmd[tokenIndex]!='\0';tokenIndex++,i++)			{				fPart+=cmd[tokenIndex];			}			//cout<<"Fpart is :"<<fPart<<"e\n";			tokenIndex++;			for(int i=0;cmd[tokenIndex]!=' ' && cmd[tokenIndex]!='\0';tokenIndex++,i++)			{				secPart+=cmd[tokenIndex];			}			if(fPart=="R")			{				//replace the program file				cout<<"replacing file "<<endl;				cpu.pc=0; //resetting pc to 0				cpu.inCount=0;								delete [] cpu.instArr;								cpu.instArr=new string[100];//make dynamic			string line;				//			ifstream file((char*)secPart.c_str());						if (file.is_open())			{								int k=0;				while( getline( file , line ) )				{                      					cpu.instArr[k++]=line;					cpu.inCount++;					}				file.close();			}			else				cout<<" file not opened in instruction "<<endl;				cout<<"Third instruction is changed "<<cpu.instArr[2]<<" "<<endl;				}			else			{				int val=0;				istringstream(secPart)>>val;				if(fPart=="S")				{					cpu.value=val;					cout<<"after S val is "<<cpu.value<<endl;				}				if(fPart=="A")				{					cpu.value+=val;					cout<<"after A val is " <<cpu.value<<endl;					cout<<"cpu value now is "<<cpu.value<<endl;				}				if(fPart=="D")				{					cpu.value-=val;					cout<<"after D val is "<<cpu.value<<endl;				}				if(fPart=="B")				{					cpu.state=0;					blockedQueue.push(runningQueue.front());					for(int i=0;i<countOfPcbTable;i++)					{						if(cpu.pid==pcbTable[i].pid)						{							pcbTable[i]=cpu;//context switching						}					}					runningQueue.pop();					if(!readyQueue.empty())					{						runningQueue.push(readyQueue.front());						pid_t red=readyQueue.front();						for(int i=0;i<countOfPcbTable;i++)						{							if(red==pcbTable[i].pid)							{								cpu=pcbTable[i];//context switching								cpu.state=2;							}						}						readyQueue.pop();					}					else{					cout<<"after blocking ready queue is empty"<<endl;										}									}				if(fPart=="E")				{					cpu.state=-1;					cpu.dead=true;					cpu.turnaroundTime=timme-cpu.starttime;					cout<<"turn around time is "<<cpu.turnaroundTime<<endl;					for(int i=0;i<countOfPcbTable;i++)					{						if(cpu.pid==pcbTable[i].pid)						{							pcbTable[i]=cpu;//context switching							runningQueue.pop();							break;						}					}					if(!readyQueue.empty())					{						pid_t red=readyQueue.front();						for(int i=0;i<countOfPcbTable;i++)						{							if(red==pcbTable[i].pid)							{								cpu=pcbTable[i];//context switching								cpu.state=2;								runningQueue.push(cpu.pid);								break;							}						}						readyQueue.pop();					}													}				}		} //if condition of check of count and pc ends here	else	{		if(!runningQueue.empty())		{				cpu.state=-1;				cpu.dead=true;				cpu.turnaroundTime=timme-cpu.starttime;					for(int i=0;i<countOfPcbTable;i++)					{						if(cpu.pid==pcbTable[i].pid)						{							pcbTable[i]=cpu;//context switching							runningQueue.pop();							break;						}					}		}					if(!readyQueue.empty())					{						pid_t red=readyQueue.front();						for(int i=0;i<countOfPcbTable;i++)						{							if(red==pcbTable[i].pid)							{								cpu=pcbTable[i];//context switching								cpu.state=2;								runningQueue.push(cpu.pid);								break;							}						}						readyQueue.pop();					}	}		}	}		bool ifAlive()	{		//cout<<"Alive\n";		for(int i=0;i<countOfPcbTable;i++)		{			if(pcbTable[i].dead==false)				return true;		}		return true;		}			int main() {			//...................................INCHARGE PROCESS......................................		signal(SIGALRM,inputHandler);		 incPid=getpid();		pid_t pid;			pid=fork();		if(pid!=0)			contPid=pid;				while(true && pid!=0)		{			alarm(2);			pause();			//if(exitt==true)			//exit(0);		}					if(pid==0)		{			//pause();				contPid=getpid();			//cout<<"contoller here\n";			signal(SIGINT,readHandler);			signal(SIGALRM,premptHandler);			pcb firstProcess(pidSerialNo,timme);				string *commands=new string[30];			firstProcess.instArr=commands;			//METhod 1			/*ifstream myfile("firstProg.txt");					string line;															if (myfile.is_open())												{													int x=0;														while( getline( myfile , line ) )														{															firstProcess.instArr[x]=line;															firstProcess.inCount++;															//cout<<firstProcess.instArr[x]<<"line retrieeved\n";															x++;														}														myfile.close();												}												else {													cout<<"file not opened of firstprog\n";												}			*/			//Method 2						firstProcess.instArr[0]="A 3";			firstProcess.instArr[1]="S 1";			firstProcess.instArr[2]="B";			firstProcess.inCount=3;						pcbTable[countOfPcbTable++]=firstProcess;			pidSerialNo++;			//time++;			firstProcess.state=1;// initializing from			runningQueue.push(firstProcess.pid);			cpu=firstProcess;			cpu.state=2;			while(true)// continue until a process in a pcb_table exists			{				if(incCount==3)				{				kill(contPid,SIGALRM);				incCount=0;				}				//cout<<""									}				}					return 0;	}	